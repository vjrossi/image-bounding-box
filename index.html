<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Bounding Box App</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px;
        }
        #canvas-container {
            position: relative;
            margin-bottom: 20px;
            max-width: 100%;
            touch-action: none; /* Prevents page scrolling on canvas touch */
        }
        canvas {
            display: block;
            max-width: 100%;
            height: auto;
            cursor: crosshair;
        }
        #info {
            border: 1px solid #ccc;
            padding: 15px;
            border-radius: 5px;
            width: 80%;
            max-width: 400px; /* Give the info box a max width */
        }
        #info p {
            margin: 5px 0;
        }
    </style>
</head>
<body>

    <h1>Image Bounding Box</h1>
    <p>Upload an image. Drag to draw a box. Single click/tap to clear.</p>

    <input type="file" id="imageLoader" name="imageLoader" accept="image/*"/>

    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>

    <div id="info">
        <p><strong>Cursor Position:</strong> <span id="cursorCoords">N/A</span></p> <!-- NEW: Cursor coordinate display -->
        <p><strong>Source Image Size:</strong> <span id="sourceSize">N/A</span></p>
        <p><strong>Top Left (x1, y1):</strong> <span id="topLeft">N/A</span></p>
        <p><strong>Bottom Right (x2, y2):</strong> <span id="bottomRight">N/A</span></p>
        <p><strong>Bounding Box to Image Size (%):</strong> <span id="percentage">N/A</span></p>
    </div>

    <script>
        const imageLoader = document.getElementById('imageLoader');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const sourceSizeEl = document.getElementById('sourceSize');
        const topLeftEl = document.getElementById('topLeft');
        const bottomRightEl = document.getElementById('bottomRight');
        const percentageEl = document.getElementById('percentage');
        const cursorCoordsEl = document.getElementById('cursorCoords'); // NEW: Get cursor element

        let isDrawing = false;
        let wasDrawing = false; // NEW: Flag to differentiate click from drag-release
        let startX, startY;
        let originalWidth, originalHeight;
        let scaleFactor;
        let loadedImage = null;

        imageLoader.addEventListener('change', e => {
            if (!e.target.files[0]) return;
            const reader = new FileReader();
            reader.onload = event => {
                const img = new Image();
                img.onload = () => {
                    originalWidth = img.width;
                    originalHeight = img.height;
                    sourceSizeEl.textContent = `${originalWidth} x ${originalHeight}`;

                    const maxWidth = window.innerWidth * 0.9;
                    const maxHeight = window.innerHeight * 0.6;
                    scaleFactor = Math.min(maxWidth / originalWidth, maxHeight / originalHeight);

                    canvas.width = originalWidth * scaleFactor;
                    canvas.height = originalHeight * scaleFactor;
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                    loadedImage = img;
                    resetInfo();
                }
                img.src = event.target.result;
            }
            reader.readAsDataURL(e.target.files[0]);
        });

        function getEventPos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            if (evt.touches && evt.touches.length > 0) {
                return { x: evt.touches[0].clientX - rect.left, y: evt.touches[0].clientY - rect.top };
            }
            if (evt.changedTouches && evt.changedTouches.length > 0) {
                return { x: evt.changedTouches[0].clientX - rect.left, y: evt.changedTouches[0].clientY - rect.top };
            }
            return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
        }

        function startDrawing(e) {
            e.preventDefault();
            const pos = getEventPos(canvas, e);
            startX = pos.x;
            startY = pos.y;
            isDrawing = true;
            wasDrawing = false; // Reset wasDrawing flag
        }

        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();
            wasDrawing = true; // NEW: If draw() is called, it means we are dragging
            const pos = getEventPos(canvas, e);
            const currentX = pos.x;
            const currentY = pos.y;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (loadedImage) {
                ctx.drawImage(loadedImage, 0, 0, canvas.width, canvas.height);
            }
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            ctx.strokeRect(startX, startY, currentX - startX, currentY - startY);
        }

        function stopDrawing(e) {
            if (!isDrawing) return;
            isDrawing = false;

            // NEW: If we never dragged, it was a click/tap, so clear it.
            if (!wasDrawing) {
                clearBoundingBox();
                return;
            }

            e.preventDefault();
            const pos = getEventPos(canvas, e);
            updateInfo(startX, startY, pos.x, pos.y);
        }

        // NEW: Function to clear the box and reset info
        function clearBoundingBox() {
            if (loadedImage) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(loadedImage, 0, 0, canvas.width, canvas.height);
            }
            resetInfo();
        }

        // --- Event Listeners ---
        let longPressTimer;
        const longPressDelay = 300; // Shorter delay for better feel

        // --- NEW: Listeners for showing cursor coordinates ---
        canvas.addEventListener('mousemove', e => {
            if (!loadedImage) return;
            const pos = getEventPos(canvas, e);
            const originalX = Math.round(pos.x / scaleFactor);
            const originalY = Math.round(pos.y / scaleFactor);
            cursorCoordsEl.textContent = `${originalX}, ${originalY}`;

            // Also call the main draw function if drawing
            if(isDrawing) draw(e);
        });
        canvas.addEventListener('mouseleave', () => {
            cursorCoordsEl.textContent = 'N/A';
            // Also stop drawing if the mouse leaves the canvas
            if (isDrawing) stopDrawing({ preventDefault: () => {} });
        });


        // Desktop
        canvas.addEventListener('mousedown', startDrawing);
        // canvas.addEventListener('mousemove', draw); // Now handled by the combined mousemove listener
        canvas.addEventListener('mouseup', stopDrawing);

        // Mobile
        canvas.addEventListener('touchstart', e => {
            clearTimeout(longPressTimer); // Clear any previous timer
            wasDrawing = false; // Reset flag on new touch
            longPressTimer = setTimeout(() => {
                startDrawing(e);
            }, longPressDelay);
        });

        canvas.addEventListener('touchmove', e => {
            clearTimeout(longPressTimer); // If they move, it's not a long press
            if(isDrawing) {
                draw(e);
            }
        });

        canvas.addEventListener('touchend', e => {
            clearTimeout(longPressTimer);
            stopDrawing(e); // Let stopDrawing handle the logic for tap vs drag
        });

        function updateInfo(x1, y1, x2, y2) {
            const originalX1 = Math.round(Math.min(x1, x2) / scaleFactor);
            const originalY1 = Math.round(Math.min(y1, y2) / scaleFactor);
            const originalX2 = Math.round(Math.max(x1, x2) / scaleFactor);
            const originalY2 = Math.round(Math.max(y1, y2) / scaleFactor);

            topLeftEl.textContent = `${originalX1}, ${originalY1}`;
            bottomRightEl.textContent = `${originalX2}, ${originalY2}`;

            const boxWidth = originalX2 - originalX1;
            const boxHeight = originalY2 - originalY1;
            const boxArea = boxWidth * boxHeight;
            const imageArea = originalWidth * originalHeight;

            if (imageArea > 0) {
                const percentage = ((boxArea / imageArea) * 100).toFixed(2);
                percentageEl.textContent = `${percentage}%`;
            }
        }

        function resetInfo() {
            topLeftEl.textContent = 'N/A';
            bottomRightEl.textContent = 'N/A';
            percentageEl.textContent = 'N/A';
        }
    </script>

</body>
</html>
